% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RaggedExperiment-class.R,
%   R/RaggedExperiment-subset-methods.R
\docType{methods}
\name{RaggedExperiment-class}
\alias{RaggedExperiment-class}
\alias{RaggedExperiment}
\alias{class:RaggedExperiment}
\alias{rowRanges,RaggedExperiment-method}
\alias{dim,RaggedExperiment-method}
\alias{dimnames,RaggedExperiment-method}
\alias{dimnames<-,RaggedExperiment,list-method}
\alias{length,RaggedExperiment-method}
\alias{colData,RaggedExperiment-method}
\alias{colData<-,RaggedExperiment,DataFrame-method}
\alias{assay,RaggedExperiment,missing-method}
\alias{assay,RaggedExperiment,ANY-method}
\alias{assays,RaggedExperiment-method}
\alias{assayNames,RaggedExperiment-method}
\alias{show,RaggedExperiment-method}
\alias{[,RaggedExperiment,ANY,ANY,ANY-method}
\alias{overlapsAny,RaggedExperiment,Vector-method}
\alias{subsetByOverlaps,RaggedExperiment,Vector-method}
\title{RaggedExperiment objects}
\usage{
RaggedExperiment(..., colData = DataFrame())

\S4method{rowRanges}{RaggedExperiment}(x, ...)

\S4method{dim}{RaggedExperiment}(x)

\S4method{dimnames}{RaggedExperiment}(x)

\S4method{dimnames}{RaggedExperiment,list}(x) <- value

\S4method{length}{RaggedExperiment}(x)

\S4method{colData}{RaggedExperiment}(x, ...)

\S4method{colData}{RaggedExperiment,DataFrame}(x) <- value

\S4method{assay}{RaggedExperiment,missing}(x, i, ...)

\S4method{assay}{RaggedExperiment,ANY}(x, i, ..., withDimnames = TRUE)

\S4method{assays}{RaggedExperiment}(x, ..., withDimnames = TRUE)

\S4method{assayNames}{RaggedExperiment}(x, ...)

\S4method{show}{RaggedExperiment}(object)

\S4method{[}{RaggedExperiment,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\S4method{overlapsAny}{RaggedExperiment,Vector}(query, subject, maxgap = 0L,
  minoverlap = 1L, type = c("any", "start", "end", "within", "equal"), ...)

\S4method{subsetByOverlaps}{RaggedExperiment,Vector}(x, ranges, maxgap = -1L,
  minoverlap = 0L, type = c("any", "start", "end", "within", "equal"),
  invert = FALSE, ...)
}
\arguments{
\item{...}{Constructor: GRanges, list of GRanges, or GRangesList OR
assay: Additional arguments for assay. See details for more information.}

\item{colData}{A \code{\link{DataFrame}} describing samples. Length of
rowRanges must equal the number of rows in colData}

\item{x}{A RaggedExperiment object.}

\item{value}{A \code{list} of dimension names}

\item{i}{logical(1), integer(1), or character(1) indicating the
assay to be reported. For \code{[}, \code{i} can be any
supported \code{Vector} object, e.g., \code{GRanges}.}

\item{withDimnames}{logical (default TRUE) whether to use dimension names
in the resulting object}

\item{object}{A RaggedExperiment object.}

\item{j}{integer(), character(), or logical() index selecting
columns from RaggedExperiment}

\item{drop}{logical (default TRUE) whether to drop empty samples}

\item{query}{A RaggedExperiment instance.}

\item{subject}{
    Each of them can be a \link{Ranges}, \link{Views}, \link{RangesList},
    or \link{ViewsList} object.
    In addition, if \code{subject} or \code{ranges} is a \link{Ranges} object,
    \code{query} or \code{x} can be an integer vector to be converted to
    length-one ranges.

    If \code{query} (or \code{x}) is a \link{RangesList} object, then
    \code{subject} (or \code{ranges}) must also be a \link{RangesList} object.

    If both arguments are list-like objects with names, each list element
    from the 2nd argument is paired with the list element from the 1st
    argument with the matching name, if any. Otherwise, list elements are
    paired by position. The overlap is then computed between the pairs as
    described below.

    If \code{subject} is omitted, \code{query} is queried against
    itself. In this case, and only this case, the \code{drop.self}
    and \code{drop.redundant} arguments are allowed. By default,
    the result will contain hits for each range against itself, and if
    there is a hit from A to B, there is also a hit for B to A. If
    \code{drop.self} is \code{TRUE}, all self matches are dropped. If
    \code{drop.redundant} is \code{TRUE}, only one of A->B and B->A
    is returned.
  }

\item{maxgap}{
    A single integer >= -1.

    If \code{type} is set to \code{"any"}, \code{maxgap} is interpreted as
    the maximum \emph{gap} that is allowed between 2 ranges for the ranges
    to be considered as overlapping. The \emph{gap} between 2 ranges
    is the number of positions that separate them. The \emph{gap} between
    2 adjacent ranges is 0. By convention when one range has its start or
    end strictly inside the other (i.e. non-disjoint ranges), the \emph{gap}
    is considered to be -1.

    If \code{type} is set to anything else, \code{maxgap} has a special
    meaning that depends on the particular \code{type}. See \code{type}
    below for more information.
  }

\item{minoverlap}{
    A single non-negative integer.

    Only ranges with a minimum of \code{minoverlap} overlapping positions
    are considered to be overlapping.

    When \code{type} is \code{"any"}, at least one of \code{maxgap} and
    \code{minoverlap} must be set to its default value.
  }

\item{type}{
    By default, any overlap is accepted. By specifying the \code{type}
    parameter, one can select for specific types of overlap. The types
    correspond to operations in Allen's Interval Algebra (see
    references). If \code{type} is \code{start} or \code{end}, the
    intervals are required to have matching starts or ends,
    respectively. Specifying \code{equal} as the type returns the
    intersection of the \code{start} and \code{end} matches. If
    \code{type} is \code{within}, the query interval must be wholly
    contained within the subject interval. Note that all matches must
    additionally satisfy the \code{minoverlap} constraint described above.

    The \code{maxgap} parameter has special meaning with the special
    overlap types. For \code{start}, \code{end}, and \code{equal},
    it specifies the maximum difference in the starts, ends or both,
    respectively. For \code{within}, it is the maximum amount by which
    the subject may be wider than the query. If \code{maxgap} is set to -1
    (the default), it's replaced internally by 0.
  }

\item{ranges}{
    Each of them can be a \link{Ranges}, \link{Views}, \link{RangesList},
    or \link{ViewsList} object.
    In addition, if \code{subject} or \code{ranges} is a \link{Ranges} object,
    \code{query} or \code{x} can be an integer vector to be converted to
    length-one ranges.

    If \code{query} (or \code{x}) is a \link{RangesList} object, then
    \code{subject} (or \code{ranges}) must also be a \link{RangesList} object.

    If both arguments are list-like objects with names, each list element
    from the 2nd argument is paired with the list element from the 1st
    argument with the matching name, if any. Otherwise, list elements are
    paired by position. The overlap is then computed between the pairs as
    described below.

    If \code{subject} is omitted, \code{query} is queried against
    itself. In this case, and only this case, the \code{drop.self}
    and \code{drop.redundant} arguments are allowed. By default,
    the result will contain hits for each range against itself, and if
    there is a hit from A to B, there is also a hit for B to A. If
    \code{drop.self} is \code{TRUE}, all self matches are dropped. If
    \code{drop.redundant} is \code{TRUE}, only one of A->B and B->A
    is returned.
  }

\item{invert}{
    If \code{TRUE}, keep only the ranges in \code{x} that do \emph{not}
    overlap \code{ranges}.
  }
}
\value{
constructor returns a \code{RaggedExperiment} object

'rowRanges' returns a \code{\link{GRanges}} object
    summarizing ranges corresponding to \code{assay()} rows.

'assays' returns a \code{\link{SimpleList}}

'overlapsAny' returns a logical vector of length equal
    to the number of rows in the \code{query}; \code{TRUE} when the
    copy number region overlaps the \code{subject}.

'subsetByOverlaps' returns a RaggedExperiment containing
    only copy number regions overlapping \code{subject}.
}
\description{
The \code{RaggedExperiment} class is a container for
    storing range-based data, including but not limited to copy
    number data, and mutation data. It can store a collection of
    \code{GRanges} objects, as it is derived from the
    \code{GenomicRangesList}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{rowRanges}: rowRanges accessor

\item \code{dim}: get dimensions (number of sample-specific row
ranges by number of samples)

\item \code{dimnames}: get row (sample-specific) range names
and sample names

\item \code{dimnames<-}: set row (sample-specific) range names
and sample names

\item \code{length}: get the length of row vectors in the object,
similar to \linkS4class{SummarizedExperiment}

\item \code{colData}: get column data

\item \code{colData<-}: change the colData

\item \code{assay}: assay missing method uses first metadata column

\item \code{assay}: assay numeric method.

\item \code{assays}: assays

\item \code{assayNames}: names in each assay

\item \code{show}: show method

\item \code{[}: Subset a RaggedExperiment object

\item \code{overlapsAny}: Determine whether copy number ranges
defined by \code{query} overlap ranges of \code{subject}.

\item \code{subsetByOverlaps}: Subset the RaggedExperiment to contain only
copy number ranges overlapping ranges of \code{subject}.
}}

\section{Constructors}{


\code{RaggedExperiment(..., colData=DataFrame())}: Creates a
RaggedExperiment object using multiple \code{GRanges} objects or a list
of \code{GRanges} objects.  Additional column data may be provided
as a \code{DataFrame} object.
}

\section{Subsetting}{


In the following, 'x' represents a \code{RaggedExperiment} object:

   \code{x[i, j]}: Get ranges or elements (\code{i} and \code{j},
   respectively) with optional metadata columns where \code{i} or \code{j}
   can be missing, an NA-free logical, numeric, or character vector.
}

\section{Coercion}{


Coercion possible from
\linkS4class{GRangesList} to RaggedExperiment and vice versa.
Here \code{object} represents a
\code{GRangesList}: \code{as(object, "RaggedExperiment")}. Here
\code{object} represents a \code{RaggedExperiment}:
\code{as(object, "GRangesList")}.
}

\examples{
## Create an empty RaggedExperiment instance
re0 <- RaggedExperiment()
re0

## Create a couple of GRanges objects with row ranges names
sample1 <- GRanges(
    c(a = "chr1:1-10:-", b = "chr1:11-18:+"),
    score = 1:2)
sample2 <- GRanges(
    c(c = "chr2:1-10:-", d = "chr2:11-18:+"),
    score = 3:4)

## Include column data
colDat <- DataFrame(id = 1:2)

## Create a RaggedExperiment object from a couple of GRanges
re1 <- RaggedExperiment(sample1=sample1, sample2=sample2, colData = colDat)
re1

## With list of GRanges
lgr <- list(sample1 = sample1, sample2 = sample2)

## Create a RaggedExperiment from a list of GRanges
re2 <- RaggedExperiment(lgr, colData = colDat)

grl <- GRangesList(sample1 = sample1, sample2 = sample2)

## Create a RaggedExperiment from a GRangesList
re3 <- RaggedExperiment(grl, colData = colDat)

## Subset a RaggedExperiment
assay(re3[c(1, 3),])
subsetByOverlaps(re3, GRanges("chr1:1-5"))  # by ranges
}
