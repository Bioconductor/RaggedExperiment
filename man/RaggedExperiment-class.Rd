% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RaggedExperiment-class.R,
%   R/RaggedExperiment-subset-methods.R
\docType{methods}
\name{RaggedExperiment-class}
\alias{RaggedExperiment-class}
\alias{RaggedExperiment}
\alias{class:RaggedExperiment}
\alias{rowRanges,RaggedExperiment-method}
\alias{dim,RaggedExperiment-method}
\alias{dimnames,RaggedExperiment-method}
\alias{colData,RaggedExperiment-method}
\alias{assay,RaggedExperiment,missing-method}
\alias{assay,RaggedExperiment,ANY-method}
\alias{assays,RaggedExperiment-method}
\alias{assayNames,RaggedExperiment-method}
\alias{show,RaggedExperiment-method}
\alias{[,RaggedExperiment,ANY,ANY,ANY-method}
\alias{overlapsAny,RaggedExperiment,Vector-method}
\alias{subsetByOverlaps,RaggedExperiment,Vector-method}
\title{RaggedExperiment objects}
\usage{
RaggedExperiment(..., colData = DataFrame())

\S4method{rowRanges}{RaggedExperiment}(x, ...)

\S4method{dim}{RaggedExperiment}(x)

\S4method{dimnames}{RaggedExperiment}(x)

\S4method{colData}{RaggedExperiment}(x, ...)

\S4method{assay}{RaggedExperiment,missing}(x, i, ...)

\S4method{assay}{RaggedExperiment,ANY}(x, i, ..., withDimnames = TRUE)

\S4method{assays}{RaggedExperiment}(x, ..., withDimnames = TRUE)

\S4method{assayNames}{RaggedExperiment}(x, ...)

\S4method{show}{RaggedExperiment}(object)

\S4method{[}{RaggedExperiment,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\S4method{overlapsAny}{RaggedExperiment,Vector}(query, subject, maxgap = 0L,
  minoverlap = 1L, type = c("any", "start", "end", "within", "equal"), ...)

\S4method{subsetByOverlaps}{RaggedExperiment,Vector}(query, subject,
  maxgap = 0L, minoverlap = 1L, type = c("any", "start", "end", "within",
  "equal"), invert = FALSE, ...)
}
\arguments{
\item{...}{Constructor: GRanges, list of GRanges, or GRangesList OR
assay: Additional arguments for assay. See details for more information.}

\item{colData}{A \code{\link{DataFrame}} describing samples. Length of
rowRanges must equal the number of rows in colData}

\item{x}{A RaggedExperiment object.}

\item{i}{logical(1), integer(1), or character(1) indicating the
assay to be reported. For \code{[}, \code{i} can be any
supported \code{Vector} object, e.g., \code{GRanges}.}

\item{withDimnames}{logical (default TRUE) whether to use dimension names
in the resulting object}

\item{object}{A RaggedExperiment object.}

\item{j}{integer(), character(), or logical() index selecting
columns from RaggedExperiment}

\item{drop}{logical (default TRUE) whether to drop empty samples}

\item{query}{A RaggedExperiment instance.}

\item{subject}{
    Each of them can be a \link{Ranges}, \link{Views}, \link{RangesList},
    \link{ViewsList}, or \link{RangedData} object.
    In addition, if \code{subject} is a \link{Ranges} object, \code{query}
    can be an  integer vector to be converted to length-one ranges.

    If \code{query} is a \link{RangesList} or \link{RangedData},
    \code{subject} must be a \link{RangesList} or \link{RangedData}.
    If both lists have names, each element from the subject is paired
    with the element from the query with the matching name, if any.
    Otherwise, elements are paired by position. The overlap is then
    computed between the pairs as described below.

    If \code{subject} is omitted, \code{query} is queried against
    itself. In this case, and only this case, the \code{drop.self}
    and \code{drop.redundant} arguments are allowed. By default,
    the result will contain hits for each range against itself, and if
    there is a hit from A to B, there is also a hit for B to A. If
    \code{drop.self} is \code{TRUE}, all self matches are dropped. If
    \code{drop.redundant} is \code{TRUE}, only one of A->B and B->A
    is returned.
  }

\item{maxgap}{
    Intervals with a separation of \code{maxgap} or less and a minimum
    of \code{minoverlap} overlapping positions, allowing for
    \code{maxgap}, are considered to be overlapping.  \code{maxgap}
    should be a scalar, non-negative, integer. \code{minoverlap}
    should be a scalar, positive integer.
  }

\item{minoverlap}{
    Intervals with a separation of \code{maxgap} or less and a minimum
    of \code{minoverlap} overlapping positions, allowing for
    \code{maxgap}, are considered to be overlapping.  \code{maxgap}
    should be a scalar, non-negative, integer. \code{minoverlap}
    should be a scalar, positive integer.
  }

\item{type}{
    By default, any overlap is accepted. By specifying the \code{type}
    parameter, one can select for specific types of overlap. The types
    correspond to operations in Allen's Interval Algebra (see
    references). If \code{type} is \code{start} or \code{end}, the
    intervals are required to have matching starts or ends,
    respectively. While this operation seems trivial, the naive
    implementation using \code{outer} would be much less
    efficient. Specifying \code{equal} as the type returns the
    intersection of the \code{start} and \code{end} matches. If
    \code{type} is \code{within}, the query interval must be wholly
    contained within the subject interval. Note that all matches must
    additionally satisfy the \code{minoverlap} constraint described above.

    The \code{maxgap} parameter has special meaning with the special
    overlap types. For \code{start}, \code{end}, and \code{equal},
    it specifies the maximum difference in the starts, ends or both,
    respectively. For \code{within}, it is the maximum amount by which
    the subject may be wider than the query.
  }

\item{invert}{
    If \code{TRUE}, keep only the query ranges that do \emph{not}
    overlap the subject.
  }
}
\value{
constructor returns a \code{RaggedExperiment} object

'rowRanges' returns a \code{\link{GRanges}} object
    summarizing ranges corresponding to \code{assay()} rows.

'assays' returns a \code{\link{SimpleList}}

\code{overlapsAny} returns a logical vector of length equal
    to the number of rows in the \code{query}; \code{TRUE} when the
    copy number region overlaps the \code{subject}.

\code{subsetByOverlaps} returns a RaggedExperiment containing
    only copy number regions overlapping \code{subject}.
}
\description{
The \code{RaggedExperiment} class is a container for
    storing range-based data, including but not limited to copy
    number data, and mutation data. It can store a collection of
    \code{GRanges} objects, as it is derived from the
    \code{GenomicRangesList}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{rowRanges}: rowRanges accessor

\item \code{dim}: get dimensions (number of sample-specific row
ranges by number of samples)

\item \code{dimnames}: get row (sample-specific) range names and sample
names

\item \code{colData}: get column data

\item \code{assay}: assay missing method uses first metadata column

\item \code{assay}: assay numeric method.

\item \code{assays}: assays

\item \code{assayNames}: names in each assay

\item \code{show}: show method

\item \code{[}: Subset a RaggedExperiment object

\item \code{overlapsAny}: Determine whether copy number ranges
defined by \code{query} overlap ranges of \code{subject}.

\item \code{subsetByOverlaps}: Subset the RaggedExperiment to contain only
copy number ranges overlapping ranges of \code{subject}.
}}

\section{Constructors}{


\code{RaggedExperiment(..., colData=DataFrame())}: Creates a
RaggedExperiment object using multiple \code{GRanges} objects or a list
of \code{GRanges} objects.  Additional column data may be provided
as a \code{DataFrame} object.
}

\section{Subsetting}{


In the following, 'x' represents a \code{RaggedExperiment} object:

   \code{x[i, j]}: Get ranges or elements (\code{i} and \code{j},
   respectively) with optional metadata columns where \code{i} or \code{j}
   can be missing, an NA-free logical, numeric, or character vector.
}

\section{Coercion}{
 

Coercion possible from
\link[MultiAssayExperiment]{RangedRaggedAssay} to
RaggedExperiment. Here \code{object} represents a
\code{RangedRaggedAssay}: \code{as(object, "RaggedExperiment")}
}

\examples{
## Create an empty RaggedExperiment instance
re0 <- RaggedExperiment()
re0

## Create a couple of GRanges objects with row ranges names
sample1 <- GRanges(
    c(a = "chr1:1-10:-", b = "chr1:11-18:+"),
    score = 1:2)
sample2 <- GRanges(
    c(c = "chr2:1-10:-", d = "chr2:11-18:+"),
    score = 3:4)

## Include column data
colDat <- DataFrame(id = 1:2)

## Create a RaggedExperiment object from a couple of GRanges
re1 <- RaggedExperiment(sample1=sample1, sample2=sample2, colData = colDat)
re1

## With list of GRanges
lgr <- list(sample1 = sample1, sample2 = sample2)

## Create a RaggedExperiment from a list of GRanges
re2 <- RaggedExperiment(lgr, colData = colDat)

grl <- GRangesList(sample1 = sample1, sample2 = sample2)

## Create a RaggedExperiment from a GRangesList
re3 <- RaggedExperiment(grl, colData = colDat)

## Subset a RaggedExperiment
assay(re3[c(1, 3),])
subsetByOverlaps(re3, GRanges("chr1:1-5"))  # by ranges
}
