% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assay-functions.R
\name{assay-functions}
\alias{assay-functions}
\alias{sparseAssay}
\alias{compactAssay}
\alias{disjoinAssay}
\alias{qreduceAssay}
\title{Create simplified representation of ragged assay data.}
\usage{
sparseAssay(x, i = 1, withDimnames = TRUE, background = NA_integer_)

compactAssay(x, i = 1, withDimnames = TRUE, background = NA)

disjoinAssay(x, simplifyDisjoin, i = 1, withDimnames = TRUE,
  background = NA)

qreduceAssay(x, query, simplifyReduce, i = 1, withDimnames = TRUE,
  background = NA)
}
\arguments{
\item{x}{A \code{RaggedExperiment} object}

\item{i}{integer(1) or character(1) name of assay to be
transformed.}

\item{withDimnames}{logical(1) include dimnames on the returned
matrix. When there are no explict rownames, these are
manufactured with \code{as.character(rowRanges(x))}; rownames
are always manufactured for \code{compactAssay()} and
\code{disjoinAssay()}.}

\item{background}{A value (default NA) for the returned matrix after
\code{*Assay} operations}

\item{simplifyDisjoin}{A \code{function} / functional operating on a
    \code{*List}, where the elements of the list are all within-sample
    assay values from ranges overlapping each disjoint range. For
    instance, to use the \code{simplifyDisjoin=mean} of overlapping ranges,
    where ranges are characterized by integer-valued scores, the
    entries are calculated as \preformatted{
                    a
    original: |-----------|
                        b
                   |----------|

                a    a, b   b
    disjoint: |----|------|---|

    values <- IntegerList(a, c(a, b), b)
    simplifyDisjoin(values)
    }}

\item{query}{\code{GRanges} providing regions over which reduction
is to occur.}

\item{simplifyReduce}{A \code{function} / functional accepting arguments
    \code{score}, \code{range}, and \code{qrange}:

    \itemize{

        \item{\code{score}} A \code{*List}, where each list element
            corresponds to a cell in the matrix to be returned by
            \code{qreduceAssay}. Vector elements correspond to
            ranges overlapping query. The \code{*List} objects
            support many vectorized mathematical operations, so
            \code{simplifyReduce} can be implemented efficiently.

        \item{\code{range}} A \code{GRangesList} instance,
            'parallel' to \code{score}. Each element of the list
            corresponds to a cell in the matrix to be returned by
            \code{qreduceAssay}. Each range in the element
            corresponds to the range for which the \code{score}
            element applies.

        \item{\code{qrange}} A \code{GRanges} instance with the
             same length as \code{score}, providing the query range
             window to which the corresponding scores apply.

    }}
}
\value{
\code{sparseAssay()}: A matrix() with dimensions
    \code{dim(x)}. Elements contain the assay value for the \emph{i}th
    range and \emph{j}th sample.

\code{compactAssay()}: Samples with identical range are placed
    in the same row. Non-disjoint ranges are NOT collapsed.

\code{disjoinAssay()}: A matrix with number of rows equal
    to number of disjoint ranges across all samples. Elements of
    the matrix are summarized by applying \code{simplifyDisjoin()} to
    assay values of overlapping ranges

\code{qreduceAssay()}: A matrix() with dimensions
    \code{length(query) x ncol(x)}. Elements contain assay
    values for the ith query range and jth sample, summarized
    according to the function \code{simplifyReduce}.
}
\description{
These methods transform \code{assay()} from the
    default (i.e., \code{sparseAssay()}) representation to various
    forms of more dense representation. \code{compactAssay()}
    collapses identical ranges across samples into a single
    row. \code{disjoinAssay()} creates disjoint (non-overlapping)
    regions, simplifies values within each sample in a
    user-specified manner, and returns a matrix of disjoint regions
    x samples.

This method transforms \code{assay()} from the default
    (i.e., \code{sparseAssay()}) representation to a reduced
    representation summarizing each original range overlapping
    ranges in \code{query}. Reduction in each cell can be tailored
    to indivdual needs using the \code{simplifyReduce} functional argument.
}
\examples{
x <- RaggedExperiment(GRangesList(
    GRanges(c("A:1-3", "A:4-5", "A:10-15"), score=1:3),
    GRanges(c("A:4-5", "B:1-3"), score=4:5)
))
query <- GRanges(c("A:1-2", "A:4-5", "B:1-5"))

weightedmean <- function(scores, ranges, qranges)
    ## weighted average score per query range
    sum(scores * width(ranges)) / sum(width(ranges))
qreduceAssay(x, query, weightedmean)

\dontrun{
    ## Extended example: non-silent mutations, summarized by genic
    ## region

    suppressPackageStartupMessages({
        library(TxDb.Hsapiens.UCSC.hg19.knownGene)
        library(org.Hs.eg.db)
        library(GenomeInfoDb)
        library(MultiAssayExperiment)
    })

    ## TCGA Multi-assay experiment to RaggedExperiment

    url <- "http://s3.amazonaws.com/multiassayexperiments/accMAEO.rds"
    ## download.file(url, fl <- tempfile())
    ## fl <- "accMAEO.rds"
    mae <- readRDS(fl)[, , c("RNASeq2GeneNorm", "CNASNP", "Mutations")]

    ## genomic coordinates

    gn <- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)
    gn <- keepStandardChromosomes(granges(gn), pruning.mode="coarse")
    seqlevelsStyle(gn) <- "NCBI"

    ## reduce mutations, marking any genomic range with non-silent
    ## mutation as FALSE

    nonsilent <- function(scores, ranges, qranges)
        any(scores != "Silent")
    re <- as(mae[["Mutations"]], "RaggedExperiment")
    mutations <- qreduceAssay(re, gn, nonsilent, "Variant_Classification")

    ## reduce copy number

    re <- as(mae[["CNASNP"]], "RaggedExperiment")
    cn <- qreduceAssay(re, gn, weightedmean, "Segment_Mean")
}
}
